shader_type spatial;
render_mode unshaded, world_vertex_coords;

uniform bool show_steps = false;
uniform int step_count = 200;
uniform float dist_epsilon = 0.0005;
uniform int ao_step_count = 80;
uniform float ao_dist_epsilon = 0.001;
uniform float ao_ray_offset = 0.01;
uniform float ao_sample_count = 4;

uniform float FRAME;
uniform sampler2D noise_tex : hint_black;

varying vec3 camera_position;
varying vec3 vertex_position;
void vertex()
{
     camera_position = CAMERA_MATRIX[3].xyz;
     vertex_position = VERTEX;
}

float pSphere(float r, vec3 p)
{
     return length(p) - r;
}

float pBox(vec3 b, vec3 p)
{
     vec3 q = abs(p) - b;
     return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

float pFrame(vec3 size, float thickness, vec3 p)
{
     p = abs(p) - size;
     vec3 q = abs(p + thickness) - thickness;
     float a = length(max(vec3(p.x,q.y,q.z), 0.0)) + min(max(p.x, max(q.y, q.z)), 0.0);
     float b = length(max(vec3(q.x,p.y,q.z), 0.0)) + min(max(q.x, max(p.y, q.z)), 0.0);
     float c = length(max(vec3(q.x,q.y,p.z), 0.0)) + min(max(q.x, max(q.y, p.z)), 0.0);
     return min(min(a, b), c);
}

float pTorus(float r1, float r2, vec3 p)
{
     vec2 q = vec2(length(p.xz) - r1, p.y);
     return length(q) - r2;
}

float pCappedTorus(vec2 sc, float ra, float rb, vec3 p)
{
     p.x = abs(p.x);
     float k = (sc.y*p.x > sc.x*p.y) ? dot(p.xy, sc) : length(p.xy);
     return sqrt(dot(p,p) + ra*ra - 2.0*ra*k) - rb;
}

float pLink(float le, float r1, float r2, vec3 p)
{
     vec3 q = vec3(p.x, max(abs(p.y) - le, 0.0), p.z);
     return length(vec2(length(q.xy) - r1, q.z)) - r2;
}

float pInfCylinder(float r, vec3 p)
{
     return length(p.xz) - r;
}

float pCone(vec2 c, float h, vec3 p)
{
    // c is the sin/cos of the angle
     vec2 q = h*vec2(c.x/c.y, -1.0);

     vec2 w = vec2(length(p.xz), p.y);
     vec2 a = w - q*clamp(dot(w,q) / dot(q,q), 0.0, 1.0);
     vec2 b = w - q*vec2(clamp(w.x/q.x, 0.0, 1.0 ), 1.0);
     float k = sign(q.y);
     float d = min(dot(a,a), dot(b, b));
     float s = max(k * (w.x*q.y-w.y*q.x), k * (w.y-q.y));
     return sqrt(d) * sign(s);

     // bound:
     // float q = length(p.xz);
     // return max(dot(c.xy,vec2(q,p.y)),-h-p.y);
}

float pInfCone(vec2 c, vec3 p)
{
    // c is the sin/cos of the angle
    vec2 q = vec2( length(p.xz), -p.y );
    float d = length(q-c*max(dot(q,c), 0.0));
    return d * ((q.x*c.y-q.y*c.x<0.0)?-1.0:1.0);
}

float pPlane(vec3 normal, float dist, vec3 p)
{
     return dot(normal, p) - dist;
}

float pHexPrism(float h, float r, vec3 p)
{
    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);
    p = abs(p);
    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;
    vec2 d = vec2(
            length(p.xy-vec2(clamp(p.x,-k.z*r,k.z*r), r))*sign(p.y-r),
            p.z-h);
    return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// bound
float pTriPrism(float h, float r, vec3 p)
{
    vec3 q = abs(p);
    return max(q.z-h,max(q.x*0.866025+p.y*0.5,-p.y)-r*0.5);
}

float pCapsule(float r, float h, vec3 p)
{
    p.y -= clamp( p.y, 0.0, h );
    return length( p ) - r;
}

float pCylinder(float r, float h, vec3 p)
{
    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);
    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

float pCappedCone(float h, float r1, float r2, vec3 p)
{
    vec2 q = vec2( length(p.xz), p.y );
    vec2 k1 = vec2(r2,h);
    vec2 k2 = vec2(r2-r1,2.0*h);
    vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);
    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2,k2), 0.0, 1.0 );
    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;
    return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );
}

float pSolidAngle(vec2 c, float r, vec3 p)
{
    // c is the sin/cos of the angle
    vec2 q = vec2( length(p.xz), p.y );
    float l = length(q) - r;
    float m = length(q - c*clamp(dot(q,c),0.0,r) );
    return max(l,m*sign(c.y*q.x-c.x*q.y));
}

float pRoundCone(float r1, float r2, float h, vec3 p)
{
    vec2 q = vec2( length(p.xz), p.y );

    float b = (r1-r2)/h;
    float a = sqrt(1.0-b*b);
    float k = dot(q,vec2(-b,a));

    if( k < 0.0 ) return length(q) - r1;
    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;

    return dot(q, vec2(a,b) ) - r1;
}

// bound
float pEllipsoid(vec3 r, vec3 p)
{
    float k0 = length(p/r);
    float k1 = length(p/(r*r));
    return k0*(k0-1.0)/k1;
}

float pOctahedron(float s, vec3 p)
{
    p = abs(p);
    float m = p.x+p.y+p.z-s;
    vec3 q;
            if( 3.0*p.x < m ) q = p.xyz;
    else if( 3.0*p.y < m ) q = p.yzx;
    else if( 3.0*p.z < m ) q = p.zxy;
    else return m*0.57735027;

    float k = clamp(0.5*(q.z-q.y+s),0.0,s);
    return length(vec3(q.x,q.y-s+k,q.z-k));

    // bound
    // p = abs(p);
    // return (p.x+p.y+p.z-s)*0.57735027;
}

float pPyramid(float h, vec3 p)
{
    float m2 = h*h + 0.25;

    p.xz = abs(p.xz);
    p.xz = (p.z>p.x) ? p.zx : p.xz;
    p.xz -= 0.5;

    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);

    float s = max(-q.x,0.0);
    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );

    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;
    float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);

    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);

    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));
}

vec3 mTranslation(vec3 inv_translation, vec3 p)
{
    return p + inv_translation;
}

vec3 mRotation(mat3 inv_rotation, vec3 p)
{
    return inv_rotation * p;
}

vec3 mMirror(vec3 normal, float dist, vec3 p)
{
    float d = max(0.0, dot(normal, p) - dist);
    return p - 2.0 * d * normal;
}

vec3 mRepInf(vec3 cell_size, vec3 p)
{
    vec3 inv_cell_size = vec3(greaterThan(cell_size, vec3(0.0))) * 1.0 / cell_size;
    return p - cell_size * round(p * inv_cell_size);
}

vec3 mRepLim(vec3 cell_size, vec3 grid_size, vec3 p)
{
    return p - cell_size * clamp(round(p / cell_size), -grid_size, grid_size);
}

vec3 mElongation(vec3 elongation, vec3 p)
{
    return p - clamp(p, -elongation, elongation);
}

float oUnion(float d1, float d2)
{
    return min(d1, d2);
}

float oSubtraction(float d1, float d2)
{
    return max(d1, -d2);
}

float oIntersection(float d1, float d2)
{
    return max(d1, d2);
}

float oOnion(float thickness, float d)
{
    return abs(d) - thickness;
}

float oThicken(float thickness, float d)
{
    return d - thickness;
}

float oSmoothUnion(float k, float d1, float d2)
{
    float h = clamp(0.5 + 0.5*(d1 - d2) / k, 0.0, 1.0);
    return mix(d1, d2, h) - k*h*(1.0-h);
}

float oSmoothSubtraction(float k, float d1, float d2)
{
    float h = clamp(0.5 - 0.5*(d1 + d2) / k, 0.0, 1.0);
    return mix(d1, -d2, h) + k*h*(1.0-h);
}

float oSmoothIntersection(float k, float d1, float d2)
{
    float h = clamp(0.5 - 0.5*(d1 - d2) / k, 0.0, 1.0);
    return mix(d1, d2, h) + k*h*(1.0-h);
}

uniform vec3 TrIn_1;
uniform vec3 TrIn_2;
uniform mat3 RoIn_3;
uniform vec2 CaGe_4;
uniform float CaRa_5;
uniform float CaRa_6;
uniform vec3 TrIn_7;
uniform mat3 RoIn_8;
uniform vec2 CaGe_9;
uniform float CaRa_10;
uniform float CaRa_11;
uniform vec3 TrIn_12;
uniform vec3 TrIn_13;
uniform float CaRa_14;
uniform float CaHe_15;
uniform vec3 TrIn_16;
uniform mat3 RoIn_17;
uniform vec2 CaGe_18;
uniform float CaRa_19;
uniform float CaRa_20;
uniform float CaRa_21;
uniform float CaHe_22;

float sdf(vec3 p0)
{
    float d1;
    float d2;
    float d3;
    float d4;
    float d5;

    {
            vec3 p1 = mTranslation(TrIn_1, p0);
            {
                    vec3 p2 = mTranslation(TrIn_2, p1);
                    {
                            vec3 p3 = mRotation(RoIn_3, p2);
                            d1 = pCappedTorus(CaGe_4, CaRa_5, CaRa_6, p3);
                    }
            }
            {
                    vec3 p2 = mTranslation(TrIn_7, p1);
                    {
                            vec3 p3 = mRotation(RoIn_8, p2);
                            d2 = pCappedTorus(CaGe_9, CaRa_10, CaRa_11, p3);
                    }
            }
    }
    {
            vec3 p1 = mTranslation(TrIn_12, p0);
            {
                    vec3 p2 = mTranslation(TrIn_13, p1);
                    d3 = pCapsule(CaRa_14, CaHe_15, p2);
            }
            {
                    vec3 p2 = mTranslation(TrIn_16, p1);
                    {
                            vec3 p3 = mRotation(RoIn_17, p2);
                            d4 = pCappedTorus(CaGe_18, CaRa_19, CaRa_20, p3);
                    }
            }
    }
    return oUnion(  d5 = pCapsule(CaRa_21, CaHe_22, p0);
, oUnion(d2, oUnion(d1, oUnion(d3, d4))));
}

vec3 normal(vec3 p)
{
    vec2 e = vec2(1.0, -1.0) * 0.0001;
    return normalize(e.xyy * sdf(p + e.xyy) +
                                     e.yyx * sdf(p + e.yyx) +
                                     e.yxy * sdf(p + e.yxy) +
                                     e.xxx * sdf(p + e.xxx));
}

// returns -1: sky, 0: inside, 1: hit
int cast_ray(inout float t, out int i, vec3 pos, vec3 dir)
{
    float dist = sdf(pos + t * dir);
    if (dist < 0.0)
            return 0;

    for (i = 0; i < step_count; i++)
    {
            dist = sdf(pos + t * dir);
            if (dist < dist_epsilon * t)
                    return 1;

            t += dist;
            if (t > 1000.0)
                    return -1;
    }

    return 1;
}

bool env_ray(vec3 pos, vec3 dir)
{
    float t = ao_ray_offset;

    float dist = sdf(pos + t * dir);
    if (dist < 0.0)
            return false;

    for (int i = 0; i < ao_step_count; i++)
    {
            dist = sdf(pos + t * dir);
            if (dist < ao_dist_epsilon * t)
                    return false;

            t += dist;
            if (t > 1000.0)
                    return true;
    }

    return false;
}

vec3 env_color(vec3 dir)
{
    if (dir.y > 0.0)
            return mix(vec3(0.0, 0.5, 1.0), vec3(0.0, 0.1, 0.8), dir.y);
    else
            return mix(vec3(0.0, 0.5, 1.0), vec3(0.8, 0.7, 0.6), pow(-dir.y, 0.5));
}

void fragment()
{
    vec3 pos = camera_position;
    vec3 dir = normalize(vertex_position - camera_position);

    float t = dist_epsilon;
    int i;
    int hit = cast_ray(t, i, pos, dir);

    if (show_steps)
    {
            ALBEDO = vec3(log(float(i) / float(step_count) + 1.0) / log(2.0));
    }
    else if (hit == -1)
    {
            ALBEDO = env_color(dir);
    }
    else if (hit == 0)
    {
            ALBEDO = vec3(1.0, 0.0, 0.5);
    }
    else
    {
            pos += t * dir;
            ALBEDO = vec3(0.0);

            vec3 N = normal(pos);
            vec3 L = normalize(vec3(1, 5, 2));
            float NdotL = clamp(dot(N, L), 0.0, 1.0);

            vec2 uv = SCREEN_UV * VIEWPORT_SIZE / vec2(textureSize(noise_tex, 0));
            vec3 noise = texture(noise_tex, uv).rgb;
            vec3 rand = fract(noise + FRAME * 1.61803398875);

            vec3 b1 = normalize(cross(vec3(1, 2, 3), N));
            vec3 b2 = cross(b1, N);

            for (float j = 0.0; j < ao_sample_count; j += 1.0)
            {
                    // golden ratio noise in both r and a produces correlation!
                    float r = sqrt((j + rand.x) / ao_sample_count);
                    float a = fract(j * 1.61803398875 + rand.y) * 6.28318530718;
                    vec2 tmp = r * vec2(sin(a), cos(a));

                    vec3 ao_dir = b1 * tmp.x + b2 * tmp.y + sqrt(1.0 - dot(tmp, tmp)) * N;

                    if (env_ray(pos, ao_dir))
                            ALBEDO += env_color(ao_dir) / ao_sample_count;
            }

            if (NdotL > 0.0)
            {
                    t = 0.01; i = 0;
                    if (env_ray(pos, L))
                    //if (cast_ray(t, i, pos, L) == -1)
                            ALBEDO += vec3(NdotL) * vec3(1.1, 0.8, 0.3);
            }
    }
}